hey everyone this is Daniel [ __ ] the JVM and what you're about to watch or listen depending on where you are is a long form conversation with James Ward He's a professional software developer since 1997 with much of that time spent helping developers build software that doesn't suck These are his own words He describes himself as a typed pure functional programming zealot who often compromises on his ideals to just get stuff done He's the author of several programming books the latest of which effectiented programming is the subject of a good chunk of this conversation He's a frequent conference speaker around the world and he's been recognized as a Java champion in 2021 He's currently a developer advocate for AWS and he's also the co-host of the programming podcast Happy Path Programming And we cover a lot in this conversation We coveroriented programming and good mental models or abstractions functional programming Java Scola Cotlin and about a dozen other esoteric languages that James has been exploring Speaking at conferences software engineering in the age of AI and how to help LLMs write better code and a lot more So without spoiling too much here is a long form and wide-ranging conversation with James Ward James it's good to see you Thank you for making the time welcome Yeah Yeah Thanks for all you do to help developers learn things So I'm excited to chat with you I hope I'm gonna do more of this and uh this is part of why I uh wanted to have this conversation So thank you for contributing to it Awesome So I wanted to start with uh your latest work which is uh effected effect oriented programming Um there's a lot to dig in to the book but uh one first thing that I wanted to ask is why effectiented programming Why this particular topic Yeah I think it was kind of a journey for me Um I I got into Scola It's maybe been 10 years or something I still feel like I I'm a novice in Scola but I got into Scola and was doing programming Initially I was writing my Scola like I wrote my Java And so I didn't even understand what immutability was Uh had just just no idea like like what what the benefits of Scola really were Like you know you've heard it called like Java without semicolons Yeah And that's where I started with my journey with with Scola And then I got into more functional programming and and so started to learn some of the functional programming stuff And as I got deeper in and even like going through the path of building things based on futures and and then and then getting into scholo like going down this like journey into functional programming I just realized like how much more productive I was when I was doing functional programming and how much better the quality of software that I was producing was And I became a total believer in functional programming being uh something that could really help us create higher quality software more easily And that was kind of the the uh you've you've probably heard my podcast programming but that became kind of the theme of the podcast not in every episode but a lot of episodes was like how do we make building better software easier And and I think for me effects became this this like next big improvement for how we can do exactly that How can we make like lower the bar make it easier to build higher quality software And so so Bruce and Bill and I my co-authors on effect oriented programming We we we went through a long journey to get to effectoriented programming but it kind of was was that same journey where where we we were like Bill and I were were convinced uh that Zo was was a great way and we wanted to teach people about it but uh but we we it took us four years of working on the book to get to the finished version But the first two years we we weren't writing factoriing programming We started by writing a scholar 3 book and then we switched to writing a Zo book and then we switched to effective programming And so it was kind of this like similar journey where we we didn't intend to to set from the beginning set out to start a book on effective programming When we started writing the book on Scola 3 we were like we don't Bill and I were like we don't really want to show like the the things that we don't think you should do like futures Uh we want to show like the the way to more easily build better more high quality more reliable software And so then we're like well maybe we should write a book on Zo And of course like Zonomicon and so many other great content already exists around Zo And so so we're like what what unique value could we bring here And then it became pretty clear that that the concept of effect programming is one that many developers still don't know um but has so much value to creating more reliable software that it's like yeah we we should just help more people get into effective programming And so yeah that's the long story there This is interesting because uh I didn't know that the book was not uh did not have that target from the outset Uh it was a a scholar 3 book What what was your intention at the beginning I mean were you targeting the functional programming mindset or what was the original target So we we um the original one was actually that that Bruce had written atomic cotlin and had written um a book on scholar with Diane Marsh a long time ago even so his his scholar book that he wrote with Diane Marsh came a long time ago then he wrote atomic cotlin and so the initial thought was that we would basically write atomic cotlin for scola and uh first call of three and that I we we Bruce and Bill and I wanted some project to work on together and that just seemed like an easy target But then as we we started drilling into it it's like yeah in Scola you can do mutability and Bill and I are like we do not want to show mutability like but if you're writing a scholar 3 book you probably got to show some of the parts that I wouldn't recommend people actually use and so um like future and so it so that we we got to that tension of like like we don't want to write a scholar rebook because we want we don't want to teach people the the less good ways to do things than Bill and I know and so yeah so so that was a kind of a weird journey into it I mean it's an exploratory journey and it's a normal part of a creative project I mean it's a it's not uncommon to start with a with one goal that you think you have clear in your mind but as you develop it you it morphs into something else because you find a more important topic Uh yeah and uh it it seems that this is the case for this book and it's certainly the case with my own courses because uh many of them either did not see the live still do not see the latter day or they morphed along the way Uh so even some of my own courses on uh the uh the effect systems like cats effect and zo and stuff uh did not start out like the finished version of course Yeah So and then we we also and I think you've probably seen this too we identified that there isn't a lot of content out there that helps people really understand why they would want to use an effect system what value it brings the highle concepts And so a couple years in was when we were like oh like like that's the gap that we can uniquely solve Like you can read Zeonomicon and understand Zo We didn't want to write another Zo book that we figured you and and John Deose and others have covered that space pretty well And so we were like what the unique value that we think we can bring here is to not talk about Zo really like Zo happens to be the implementation We will instead teach people the concepts of effects and effect systems and the values and the why of effect systems And so that became the focus and it's a pretty short book Um and uh and we do want to work on other versions of it Like I would love to do a Kio version I think Kio is awesome and it should be so we wrote it the book with the intention of being able to take all the code and swap all the code for some other effect system and and not have to change a whole lot of the pros around it because the concepts are really trying to generalize to effects and not be specific to the implementation of Zo That's the the uh the the thing that I appreciate most about the book I've uh I've checked out the book and uh the concepts are more of a mindset thing than the code or the particular effect system details or the particular aspects of it Uh it seems pretty easy to swap for example zero with I don't know cat's effect and the concepts will pretty much stay stay the same I was curious why you thought this was an important topic I mean the and the reason I'm I'm asking is because when people uh when I go to conferences especially like mixed programmers not just scholar conferences but also with Java programmers cotlin and stuff uh I get this I mean I get into conversations with people in different ecosystems for example in Java and cotlin and uh I find myself in the position of pitching scola to them in the sense that uh the question that comes naturally is why should I use Scala rather than Java or Cotlin with all these uh mature ecosystems or mature libraries and stuff And the kind of phrase that I came up with naturally in conversation with with these people was something along the lines of what you said which is the ability to write safe software quickly and conveniently So it's like a mix between safety and convenience Yeah So I was wondering uh how much or if you had a similar positioning or a similar uh re realization when you came up with the idea for the book because from the amount of work that came up into the book like four years is a long time so it must be an important topic So I was wondering how you thought about that Yeah Yeah It's we actually before before it became effective programming we the the concept of the book was essentially that we were saying like safety and convenience and I forget we may have it written down somewhere in a git repo but the the the draft book title was something like reliable uh you know building reliable something uh productive like like it was it was taking those ideas that you're talking about and and then we're like "Oh effects are the thing that really enables this uh really enables many developers to kind of take that next level of of the productivity and the safety uh and um the testability and the refactorability like all those all those things that developers do all day every day like effects is just a better way to do all of that um that I have some challenges with with uh with Scola being maybe the um I don't think that Scola is necessarily the the best way for your normal Java programmer to get into the world of effects and it's kind of yet to be seen what what will be Typescript effect I think is a great option for a lot of people because there's you know millions of developers that use TypeScript and the fact that Zo was basically ported to Typescript um in the effect library I think it is the biggest opportunity to get the masses more into this world For the Java and Cotlin developers I I'm not totally sure what the best options are for them My hope is that there will be a good effect system that emerges in the Cotlin ecosystem uh I I don't know when if if or ever Java will have something that would be something I would recommend in that space but um and and the Java ecosystem is largely very far away from the um concepts of safety and refactorability and you know all the functional programming stuff basically you know maybe taking small steps in that direction but yeah so I think all that to say like like yes the the goals Uh after we shifted out of the idea of creating the scholar book the goals became how do we help people create better software more easily Uh exactly what you're saying This is uh this is very interesting because uh uh it seems anecdotally that uh people that adopted this mindset do describe their own code as being safer and their experience more let's say clear that it adds clarity in the process of writing their code So it seems that effects are a sweet spot for this sort of uh this sort of let's say safety and clarity kind of mix So uh if you could describe to people because not everybody knows what effects are If you can describe to people what effects are what their main characteristics are and why they're important Oh yeah good good question Um yeah and it's good to probably talk about YFX I should have reread our YFX chapter in the book Um because it's it's a hard concept to explain especially for for someone that's not familiar with functional programming stuff So let's let's start with let's and my answer isn't as good as Bruce's Bruce uh Bruce is really good at taking these complex ideas and distilling them down into simple ways to explain things And I tend to go more into the technical things Uh that's not the right way to say it but I I'm not as clear and concise as Bruce is at at describing some of these things So So we'll find the definition as we go along here Yeah there we go We can we can work on it together So so here's here's the here's part of the way that I think about it One of the biggest challenges with with creating good software is that we often aren't able to do the I think it came from hasll the do the make illegal states unrepresentable thing and the the this this idea is that if something compiles it should work as I intended I shouldn't be able to to compile something that allows an invalid state to to exist in the system And this is the source of production bugs is that oh something that something happened that I didn't expect to happen and I didn't have the right code to deal with that situation and so now I have a production bug where they're you know in the simple form like a null pointer exception like oh gosh I forgot to check the this possible null thing Um and so there's many different levels that you can go to to make illegal states unrepresentable Uh nullability being kind of a lowhanging fruit that Cotlin really is taking advantage of A lot of people use Cotlin because oh great we get nullability just like built in And that is a make illegal states unrepresentable kind of thing because now in the type system you represent this thing can be null or not And that just uh eliminates a whole class of potential null pointer exceptions in your production system where it's like oh gosh I didn't think about the fact that this could end up being null Um and in Cotlin you're like it it's going to tell the compiler is going to tell you it's going to tell you that you have to think about those things It was amazing decision at the time the introduction of nullability So there's there's many different levels that we can go through to make illegal states unrepresentable the um going nullability I think is is an easy one to gro um the the next level let's go with typed errors So uh the the next level in related to effects for for making illegal states unrepresentable would be that we we have errors that can be produced from something likely you're you know talking to a database it's like oh can't make a connection and another source of typical is production issues is that we imagine that these errors can't happen And so oh we can't make a connection to this thing or something timed out or whatever Um we we like to go on this like like naive happy path and imagine that those air conditions can't exist And so we ignore them with uh with with exceptions is one of the common ways at our peril uh or in the case of go just the um you know oh you have to check for the the existence of this air but then most people just ignore it anyways like it doesn't there's often not the um air handling becomes something that is not helpful to the developer to to deal with the situations where things can unexpectedly go wrong It just becomes an annoyance and so I ignore it And I think we can see this with um with um uh what's the the the exceptions that in Java that you that you have to handle Um basing the name on that one Uh checked exceptions So checked exceptions probably a great idea because it then forced people to have to deal with the possible error states that can that some something can get into The problem was that they weren't really part of the type system Like they weren't expressed uh through the types in a way that led to composability to um the ability to refactor things Like if you have a a method that throws a checked exception you can't put that into like a map function and like not like how do you even handle that you know And so so what we want to do is make it easy to handle the cases where something can go wrong And so in effect systems one of the things that it represents is the possible errors that can that can come out of any given call but without sacrificing the composability of a system And so that's oftent times where it's like you can come up with other air handling models whether it's exceptions or whatever Um but until you get to the ability to have something that represents these air error situations that still composes uh that's that's one of the great things about effect system So I'll pause there and see if you have anything to clarify or add to to that piece All right So it seems that effects are these data types that kind of encapsulate the possibility of something unexpected happening or the possibility of something else other than a pure computation happening So the way that I think about it and the way that I share this with uh my um with my own students at uh in my cat's effect or zero courses is that an effect essentially describes two things One it describes the value that will be produced by the computation on the happy path And two it will describe just by its type the potential other things that may occur as well other than the computation or so the potential error that might be happening or the potential side effect that is the other um phenomenon that may happen in the real world other than the the computation of that pure value and that type is the effect So we say that that particular type is an effect because it may produce uh other things or may uh other things may happen other than the computation of a value Yep That's great Yeah Yeah Exactly Yeah So I guess I lost track of um saying what how this all relates to effects You did a great job with that Yeah So it's it's having a way to represent the these computations that can produce a a value but also can do something else And so so the the air condition is one of the something else's that can happen But then there are other things that are related as well And so then the next thing at least in the land of Zo is the dependencies that a given effect will need And so again we can represent that in the type system So we get the make illegal states unrepresentable thing and then anytime we call something that needs a dependency like a database connection we can then provide that into the environment Uh and if we forget to do that the compiler is going to tell us and not let us actually compile our program And again this in the world of Zo and I maybe all effect system maybe at least the effect systems I've worked with we're doing this without sacrificing the ability to compose things because oftent times our systems are just a bunch of side effects that all have to figure out how to work together and you know potentially work in parallel and potentially uh work in in some sequential form where different effects can produce different errors and have different dependencies and like how do we weave all that complexity together and by having an effect system one way to define these these computations that can produce errors have dependencies and we can talk about other uh models for representing effects but but at least those things how do we build bring all those all those different pieces of the application together and then we get some great benefits we get the ability to have a kind of universal model of things that can fail things that have requirements uh to be able to run So then we can on any effect do something like a dot timeout and dot timeout then doesn't become some weird thing that like like if you've got some nonffectful system it can actually be really hard to figure out like like how to how to do a timeout well because then that introduces a new possible error type Uh and so just adding a timeout to a a normal you know non-effect program can be really hard When you're in the world of effects you just say that timeout and put the you know however you want to specify your timeout on it Retry is another one And I love retry because uh m many mature libraries that are effectful library sideffecting libraries usually will have their own way to do a retry Sometimes it's internal sometimes it's you know there's some DSL on it Um but retry is actually a complex piece of machinery because how do you want to manage the actual retry scheduling Do you want to be able to do like exponential b back off How many do you want to have a max number of retries And then do you want to allow retry on something that that won't actually produce an error And so this is where in the world of Zo you get the retry on any effect but you get all the you so you can you can add a retry to anything except that you can't add it to an effect that won't produce an error It actually won't let you do that It's a compiler to try to do a retry on something that won't produce an error And so essentially the types the type describe also describes the kind of error that would be produced And just by looking at the type the compiler won't allow you to do that Yeah Exactly Yeah And so so the and the fact that you can then add retry onto any sideffecting piece of of any effect that you have is just except for the ones that don't produce errors uh becomes this like amazing thing where where you don't struggle with it like you would in a in a normal application that's you know not representing the side effects not representing the errors not representing the dependencies not representing initialization becomes initialization or or um what you want to do when you close something so the kind of open close stuff effects give you the opportunity to do all that in a reasoned way And then we call it the like superpowers One of our first chapters is like like trying to illuminate some of these superpowers that once you get into the world of effects then you just get all these superpowers for free And so adding retry to to an effect it's just that retry and you can then give it a schedule or max number of times or whatever So yeah it's it really opens up a lot of uh a lot of problems become really easy once you move into the world of effects What do you think uh a um uh a programmer could take away in a a few minutes from the mindset of effects and and the the reason and the the the reason why I'm phrasing the question in this way is that uh for many developers the concept of an effect system at least when they look at it for at the first at first sight it might seem a bit overwhelming or it might seem seem a bit complex If they look at the type signature of Zo they see all these uh all these type signatures with a variant annotations If they look at cat's effect they see uh either an IO data type that can do pretty much everything and it seems like a god kind of effect or they look at the tagless final pattern and that's particularly daunting to uh even experienced scholar developers So if you could uh give people like a a couple of major ideas that would be tremendously valuable to their progress or their career by studying effects what what might those be Yeah it's it's a good question And I think this is one of the challenges that we have is is what effects can be a large leap for a lot of people and can be an astronomical leap for many other people So if you're in the world of Java and Spring to get to a good effect system you're going to have to it's it's a it's a very large leap to go from the world of Java Spring to a good effect system there's a lot of knowledge that needs to be obtained If you're doing Scola and you're doing future-based programming in Scola then it's a much smaller leap to the world of effects because you can even shove Zo into I'm sure cats effects has this as well you can shove it into a a small piece of your application and start to get some of the benefits of effects uh and then still turn it into a future and so it still kind of fits within the the API structure that you have Um so so it's it it depends maybe on on kind of which trajectory people are coming in through it to to figure out like what's the what's the path to effects for people Um so maybe back to your your question of of what um what would be the the the best way for somebody or the biggest benefit of of someone getting into the world of effects Like why am I going to take a a small or a very large leap into this world Um why would I do that And it's it's a really good question I mean the the air handling one is is an interesting one because just immediately you get a lot of benefits but you don't necessarily need a whole effect system to do that You can you could just use an either and or you know there's different ways to represent that just that piece without going to effect systems So I don't know what do you think what's what's your what's your kind of path or or benefit statement there The way that I that I try to explain this to people is that especially in the important code it's really hard to reason about the kind of things that can go astray not necessarily wrong but in unexpected ways And so effects are good descriptions of the entire thing that you are writing So an effect is essentially a description of a program And that program contains with exact clarity what it produces when the kind of stuff that happens within that program And then that program is just a data structure because an effect really is just a data structure with a type attached to it And then you can pass that program around You can pass that as a data structure everywhere And you can combine it with other programs to com to complete bigger programs So suddenly if you start to think in terms of these effects the code that you're writing starts to become more like like Lego pieces rather than lines of code that you need to reason about especially in concurrent systems where the state of the system at any point becomes very important as you said with retries and timeouts These are two very important patterns and that occur a lot of a lot uh a lot of times in in production systems and especially in the important code where you have to get a particular resource at that particular time at Disney you have to get a particular frame at that particular time uh any errors must be handled at that particular point and so on and so forth So for the important code for the critical piece of your software it's very important to be able to compose your programs in terms of these descriptions that you can combine And effects are a good representation of what it means to have the description of a program that you can stick together in patterns that you find valuable rather than thinking about the nitty-gritty of let let me manage the retries let me manage the time let me manage the thread let me manage the whatever resource to for opening and closing and stuff like that So effects are a good encapsulation of what it means to have various mini programs or mini patterns in your code that you can replicate that you can pass around that you can repeat that you can combine or modify as your code becomes becomes more complex I Yeah I love that And there's there's two other outcomes that that um are really valuable because of this The first one is is the refactorability I think John Beos calls it the fearless refactoring or something The fact that you can now that you've got this model that this Legoike model you can take a piece refactor it out and have really high confidence that the system is still going to work when it when those Lego pieces are put back together uh composed together that things are still going to work as you expect them to So the refactorability becomes something that's that's great huge value Then the other one is the testability because now that I've got an effect that represents the sideffecting pieces the dependencies that the thing needs now it becomes much easier to write sane tests for that thing instead of you know I think generally with with complex sideing systems we just like give up on writing good tests most of the time because it's too hard to like unravel all the layers of of side effects And and now because we've been able to break things into pieces we can test those pieces independently And it becomes much easier to uh to potentially provide just the the the dependency or service that something needs to a given piece and test it in isolation without having to use mocks and and um uh fakes and and some of those things So so yeah So I think the the refactorability the testability um become two things that are not like immediately evident to effects being uh improving those other kind of tangential things in such significant ways But but yeah Yeah What do you what do you think about the refactorability testability and then anything else on it would be like ilities or something around effects Yeah I mean these are uh side effects pun intended of uh using uh using an effect system or using effects as a thinking process to organize your code And uh the refactorability is a natural extension to the description of the program kind of mindset because you get these kind of mini pieces that you can combine And when you take a piece out and then you modify it and if you keep the type signature intact you can stick it back in the code and you get the modified behavior but with the guarantee at least that's by the type description that your program is still going to work but with the extra things that you've added or that you've changed along the way Or you can take groups of programs or you can take groups of effects combine them swap them for a different pattern stick them back together And for integration testing as you said um if you have a complex program you can take a piece of core uh module out replace it by a testing environment and then the entire logic of your big software becomes uh very similar to what you would see in production but with the instrumentation or with the extra maneuverability that you get in tests so that you can verify that the code works correctly So the the composability aspect is very important Yeah Yeah And then um you mentioned concurrency and I I think we should talk a little more about that because Zo I think still kind of pitches it's one of its like primary pitches for why Zo is concurrency And there is a ton of benefit to using an effect system when you're dealing with concurrency because it kind of puts you into a a constrained model of concurrency that allows developers like me who are not like Victor Clang to actually write concurrent code in a safe way that I'm much less likely to get into deadlocks and other issues that are common in concurrency And so so certainly if if you have a bit of code that is concurrent and like really complex state management in with concurrency effects should definitely make that piece of code a whole lot more easy to reason about and get right But you yeah I mean I definitely agree with this because writing concurrent code is hard really I mean there's no way around it uh writing important concurrent code with clear safety guarantees is very difficult and unless you have a lot of discipline with it you can get burned very easily At least when your product starts meeting the customer you'll definitely get into states that you haven't thought about And so you have to be kind of like an expert programmer with a lot of discipline to be able to manage concurrent code in the let's say so-called manual style in the style of Java or in the style of uh the more mainstream or let's say bare bones concurrency models and an effect system is because it's a description of a program that description of a program can be of a certain kind So it can be for example of the kind that is able to modify a certain piece of state uh with concurrent access And because you have that Lego piece with these properties you can swap it around and you can replace it with something that's sequential or replace it with something that's uh concurrent And you get the same kind of safety guarantees And you don't need that much discipline to be able to write correct code but rather just focus on the piece of logic that you're interested in whatever your application may be And the uh effect will take care of itself because theuler internally takes care of all the bits and pieces that you would normally have to take care of if you would write that kind of code yourself Yep Yep definitely And then you get this like side effect of oh you you have this complex piece of concurrent code that's that's you know using all your cores to the max and uh and that's all great but then how do you how does that then fit into a larger system or more complex system with you know let's say you've got this concurrent piece and you want to like add a timeout on it Well then you just do timeout and boom you know it's it's an effect like anything else You get all those benefits but you can kind of constrain the the complex pieces to a given effect and then wrap that with other effects and get all these benefits But then there's one of the the places where I've seen the benefits of an effect system uh really exposed and this is I think the last chapter of our book is you get into libraries that then provide higher level abstractions over this stuff So there's the library resilience which adds bulkheads circuit breakers uh all all sorts of kind of then higher level functionality in an effect system around Zo and it's like oh god doing this like like complex bulkheading or rate limiting uh I'm which requires managing concurrent state the fact that I can just like like in a few lines of code add that kind of functionality and and get all the benefits of an effect system that we've talked about but with these higher level level concepts like then it's like oh okay the fact this really was like this like Lego structure where I was able to take these small pieces and compose them into larger pieces and then wrap them with these complex um rate limiters and bulkheads and that sort of thing and it's still in effect So that just becomes composable with other things So so yeah I I love that the the resilience library in particular really illustrated the the benefits of building out to more complex scenarios uh as well Yep So uh for everybody listening or watching if you haven't tried effects I both of us recommend at least uh diving into the mindset to see how you how how this fits your u how this fits your mind I wanted to ask one one other thing real quick before we move on is I did want to mention streams because I was I was thinking about what are some other areas where people can get like quick wins on on effects and streams is one of those places where like Z the Zoro streams library if you're doing any kind of stream processing thing whether it's you know you've got Kafka or whatever like this becomes a place where effects have so much more value because you get this really nice API to deal with the things that you normally need to do in stream processing but it still is all built on effects And so so I think um streams can be one of the places where people can get a quick win on on a quick and powerful win really because super powerful uh it's really uh easy to abstract powerful patterns that would otherwise be very difficult to write if you would do this manually or if you do this yourself Yep Yep Yes So I wanted to ask I mean you've seen a lot in in your career I mean you have an almost three decade career You have more years of software engineering experience almost that I that I have years of life So uh you uh you've seen a lot and you've seen a lot of patterns You've seen a lot of mental shifts in uh software engineering I was wondering if you have some memorable experiences where you had like these changing of mindset for yourself as a software engineer It seems like for example this effect oriented programming mind shift is one of them I was wondering if you have others as your career pro progressed Yeah it's a good question I think um I I I have had a number of of shifts I think the the general functional programming one which which came a few years after I got into Scola I started really making the the the shift to functional programming So and that started with just immutability and pure functions and um those those pieces of functional programming And so that was a huge one because I most of my my life as a programmer had done the typical imperative style of programming And so functional programming I it took me a while to kind of wrap my head around it because I I spent as you said decades like like as a you know Java developer and and writing you know not having no concept of a lot of the concept um of functional programming So so that was a huge one Um the the other yeah other mind shift switches uh there's been a lot functional programming is definitely the biggest um oh types let's talk about types because yes uh I I I went this was now a long time ago that I shifted to to types uh doing statically typed languages but there was a a huge shift for me in that because Um I early in my my actual career I was doing Pearl uh Pearl CGI and then PHP uh and then I got into Java but I didn't really understand types and type systems and the value of of all that uh until I read Bruce's book Thinking in Java and then I was like oh okay like like that was the first inkling that that these types are a powerful thing that when done well should actually make my job as a programmer easier because now I can have a compiler that's going to tell me when I've done something wrong and so um so I I think this was a huge shift for me maybe to to your audience like people are already convinced on that but that was that was for me a huge a huge leap forward but then many years later uh in in the world of Scala then discovered like like oh there's there's many more layers to what we can do with types and effects being being one of those but there's many more layers that bring us value And so the the kind of generic programming using generics um to to further constrain things again became like like oh I can use a type I can use these things in a type system to help me as a developer be more productive and uh and yeah now now types and and we can get into type classes too but but these ways to to have the compiler help me uh help me write better code faster It just became this like like of course I want to do that Of course I want to leverage the type system in in the the the best way possible So an interesting side note I've been learning uh Typescript and and the effect library for TypeScript And as part of that dove in uh to structural typing and structural typing became one of those things where I'm like I I'm not sure that I'm really like like getting the benefits of seems like a mix having a compiler um there And so so see that that was an interesting one where I'm like okay there there are other ways to manage types and and deal with them and structural typing I'm I'm not sure I'm like like convinced that it's it's a better way that really like leaps me forward like the Scola type system Like I love the Scola type system and it's one of the reasons why um I when given the choice I I write a lot of code in Scola because I love how much I can use the type system to express the intent of something and then have the compiler tell me if I'm wrong basically Did you ever feel that it hinders productivity There's one criticism of type systems that uh it's somehow that a a very strong type system or a very strict a strict uh library written around a static type system may hinder productivity because you have to kind of conform to all all these types and then you have to conform to all these shapes but then uh it's easy to write things in JavaScript and do like dot dot field where that field is a part of a huge uh a huge object and stuff and they feel that they're going faster Do you did you ever feel a hinder a hindrance in the the speed at which you developed code It's a really good point because Yeah absolutely Like you uh maybe this is best summarized by something I heard John De Go tweet about a long time ago uh he was talking about gradual typing and the idea of gradual typing is is like yeah I can kind of use types when I want to and I can um you know not not have to deal with the the pain of of types Uh now uh I can gradually adopt them And his tweet was something along the lines of so that you could uh it was it was pointing making fun of gradual typing by saying that the the downside of gradual typing is that you're going to then gradually in production find out about the problems with your with your program instead of finding out out about them at compile time And I think that is exactly right there is some some uh added time in development when you're working with types because then you actually have to think about what is the what is the correct representation of this thing and sure you're not going to be able to get to actually running your program uh faster like you know but you do know that when you get to running it it's going to actually be correct instead of gradually running the thing over and over and over again hoping that you get it right and then never refactoring the code Because if you refactor you know all all of your iterative loops of running your program all of that is all of that is just destroyed instantaneously because you no longer have the type system to validate that that it was it was correct You kind of have to recheck again whether that whether your program is correct That's right Yeah So so I think the there is overhead certainly to having to specify types and I I certainly struggle sometimes like like with I will spend time beating my head against my desk trying to figure out how to represent something with types and it maybe it doesn't feel as necessarily fulfilling as the yolo python I just run the thing and you know it's a script so like like whatever like uh I I I think there is some like like brain chemistry benefit to like oh I ran the thing and oh yeah then I found the error you know late happened to find the error later like there is some dopamine benefit to that and so it is sometimes hard to figure out what is the right typed representation of this thing but the best the the nice thing is is that I iterate on those types And then as soon as the compile works I'm like sweet Like I don't like I don't worry that Exactly Right You're just like like great I did the work in the types and now I have confidence when I when I'm that the compiler validated that this thing is actually going to work as I intend Um so yeah I think for me and then and there's many different ways to kind of represent things in types and that's where it gets a little tricky is is um what's it what's the polymorphism the general term of polymorphism for generics like I just like like there are so many or parametric polymorphism parametric polymorphism Thank you So I didn't even know about like different types of polymorphism and not even that long ago uh because I was so used to the world of Java and inheritance being really the only the primary polymorphic type and then it's like oh there are other ways to do polymorphism and generics then become just another tool in the toolbox for polymorphism essentially which is not generally how they're how they're used in Java um they're they're I don't know I guess a little bit but but not like not in the extent that we that in the world of scholar we use parametric polymorphism or generics to to help us represent things in a more complete way so that we have confidence when we actually the compiler runs great we're pretty confident this thing's going to work uh speaking of type systems how do you u you have experience with uh uh with Scola obviously with cotlin with with Java as well How do you compare the type systems of these languages and uh if you have a sort of type system that fits best with your mode of thinking Yeah I mean for me I I love Scolas because it is it is complete in terms of like like what the the it has all the like things that I could possibly need in a type system and and if it's going to get more by the way Yeah With with capabilities or capabilities Yeah Yeah Yeah So I and and of course Martin is is amazing And I haven't watched your interview yet with him but I'll have to check that one out cuz he's a he's he's amazing I mean he's been working on type systems for what like 40 years or something like like like it's just he is genius I love the like calculus stuff I love the like like relative soundness of the type system in Scola like like for me like Scola is a really amazing fantastic type system It has so much power So but so certainly Scola my favorite cotlin the biggest thing to cotlin that they did uh which we talked about a little bit was the nullability so to put the nullability in the type system um it has it has a trade-off and I'd love to hear your thoughts on this it's really nice to have a simple representation of nullability and have that built into the type system but one of the downsides to uh is that it's not generalized in a way that that could be beneficial So just as an example of this in in Cotlin because they've built nullability into the type system if you've got a nullable type you can do the question mark uh to chain operations uh null chain the operations together But that question mark only works for the nullable types when wouldn't it be nice to be able to like like chain other types of things together maybe effects together like oh my my effect was was successful Let me chain it onto another effect Um but but this was really just a specialized case for nullability in the type system when if you look at the world of Scollet there isn't a a generalized nullable type because you can represent that with an option but then you don't get some of the ergonomics that you that you get in Cotlin for nullability being being in the type system So I don't know if we've fully like like gotten to this like nirvana of balancing this like pragmatic like what Cotlin has with nullability with the more generalized solutions like you can do with Scola and Scala has So I don't know what are your thoughts on the on the trade-off between the generalized versus specialized things like that Well uh Colin is definitely hitting on a very common pattern and they built into the language something that happens all the time with relatively little effort So I'm pretty sure that they did like an 8020 uh analysis of what is the most uh let's say the most widespread source of errors and they just like hit one and they covered a a bunch like half of a programming errors like just null pointer exceptions and that's built into the compiler and that's a major win for them Um skull went all the way really with uh uh and it's and it's not even there yet I mean with the capability tracking and uh the ability to abstract away resources and uh uh access to powers in the within the type system itself uh it's still uh in development but Scolop chose a way that is the is a very general one but then you have to fit your mind to that particular style I mean in cotlin it's very easy to say question mark dot and then call a method and the compiler just takes care of whether that thing is null or not and then if it's not null then it will call the method But uh in Scola you'd have to write like a tiny bit more code to be able to to take care of that particular case but then you have many many many different tools for other kinds of things not just like a generalized version of nulls You have uh you have union types you have eithers you have options you have effects you have various kinds of um composability between uh the different kinds of types that you can have So for example um because we spoke about effects option is an effect because it returns a value if it has something and it might return null if it doesn't So it's uh it the type describes the kind of value that it will produce and it also describes the potential side effects that may be produced if they uh if need be uh either is another kind of uh effect um IO from cats effect or zo from the the zo library or uh composure of zos and stuff like that All of those are generalized versions of what you can obtain and the other things that may happen as a uh as a let's see I want to ch choose a different word uh other than effect um as a phenomenon in the real world uh other than computing a pure value and if you want to work with these kinds of values you have to conform to a specialized API you can't just call a method on the object that a zo returns You have to call map on the zo first and then call the method inside of it So you kind of have to fit that into your mind rather than just uh going into the Java kind of mindset and just add a question mark and then you're done Yeah there's one other piece to this that kind of brings together some of these concepts the to unite the like type systems and power of type systems with effects which is uh ADTS and scholar 3 uh does a great job of of representing ADTS some types product types algebraic data types algebraic data types yeah and so where this then comes to brings you some benefit as a developer in the con in the in this world of effects is let's say I've got a effect that can fail with a user not found error and I compose that with another effect that can fail with a uh I don't know cannot connect to service error when I when I compose those two effects together the air type of my new effect is then a subtype of those two things and then what's awesome is I can then pattern match on in that uh effect handler in a handler for that effect on those two things and can get an exhaustive check So the compiler can actually tell me I can actually turn on a mode which I usually do in Scola which will actually fail if I don't exhaustively check for those two types in a pattern match And so then I'm like getting this benefit of this this great complex powerful type system with effects that helped me compose and helped me make sure that when I actually when the code compiles I've now covered the the the possible ways that this particular thing can fail and the compiler is going to tell me about that And so I love how Scola 3 and and Zo really bring a lot of benefits together in this way that that you you don't really get I don't think if you're in Scola 2 even it's like the the like exhaustive pattern matching on a on a you don't get union types because there things Yeah Yeah Yeah Yeah So and and then just the ergonomics of it become easy to do the right thing which is the the concept that we're talking about is like if I've got effects and I've got a powerful type system then it should be easy to like write good code and and that's uh one of the ways that we see that kind of coming to fruition with effects and powerful type system Well hopefully more people uh can get the chance to uh explore effect systems because they're super powerful Um I wanted to ask u in your uh in the um I mean you've seen a lot of things You've seen many languages many tools many libraries many uh styles of writing code Um is there a thing or a mindset or a tool or a language you can choose whatever whatever springs to mind that has aged particularly well in the sense that you that it's been it's been here for a while let's say at least 5 years maybe 10 years or more And it has been relatively unchanged and it's and it has uh stood the test of time quite well Does anything spring to mind It's a good question I I I like to be like where I like to play is more like on the fringe where things are moving quickly where things are not likely to get adopted by the mass of developers at least anytime soon So so I've been fascinated by things like Unison and Rock Um which I I think there's probably little uh hope that those that those languages get mass adoption just because they're it's so much even further of a leap from and we're if we're talking about like Java developers or Typescript developers uh the the leap to Scala and Zo is a pretty significant one the leap to like unison and rock is is astronomically further And so while I'm fascinated by those languages I I I don't see that that they're going to gain mass adoption Um I think for me the the the thing that has where do we want to go with this Um Typescript is is a huge contender in this like future space of enterprise developers Um this more attainable way to like get a lot of these benefits that we've been talking about but but for your your normal enterprise developer So I I think that I I'm thankful that the effect folks uh who created the effect library for Typescript not confusing at all that they're that the library in the uh is called effect but effect for TypeScript I think that this is going to be a much kind of easier path for a lot of developers to get a lot of these benefits Um and I'm I'm still just like new to Typescript and and learning it But but maybe to answer your your question maybe Typescript is is the place where where things have been relatively stable Um the the language continues to to you know evolve But but but I don't think I've seen like a lot of breaking changes to the language I think it's it's been um mostly stable throughout the years Yeah Yeah and for mo for a lot of systems you need that stability Um not you know a lot of the stuff I work on I don't I don't need to worry about having thousands of engineers writing you know massive production systems I'm not working on anything that big and complex I don't have to think about some of the same concerns I get to dabble in in you know weird languages like Okamel uh and and don't have to you know worry about uh larger more complex things So um so yeah Typescript is really interesting I think the other answer to your question is which isn't exactly a language but I'm really fascinated by where WOM is is going and think that that it's it it isn't it's evolving kind of slowly but it is evolving and so I'm I'm fascinated to see like is Wom going to be uh this universal thing that that actually ends up working this time um because we've taken many attempts at this You know Java certainly Yeah JVM has been probably the most successful attempt at crossplatform development in a couple decades Yeah exactly And so Wom could be the next thing especially because it works in the browser it works on servers like like it there it has a good shot at this and so we'll we'll we'll see where where that goes there still is um some some gaps to to the world of WOM Uh and the the spec communities are continually trying to evolve the specs and but but I think I think WOM is super interesting for for what could be a target output and run times uh for for the future of developers This is super cool and I find it fascinating that you know so much uh about the uh more niche languages like Unison Rock Uh how do you how do you stay relevant or how do you explore these technologies or these tools libraries languages How do you uh do you have a process for how do you explore it Do do you like to play How how does your exploration in these in these fringe mindsets look like Yeah good question There there's kind of two sides of it One side is Bruce and I have our podcast HalfPath Programming And so through our podcast we we're like "Oh let's let's have uh Richard Feldman on because he's super smart and interesting and he built this programming language called Rock and we can just have him on and learn all about it." And so uh so through the podcast we get some initial discovery of some of these more fringe things and Bruce and I both really like programming languages and talking about programming languages So so that's been one avenue Uh the other one is a couple I think it was a couple years ago I wanted to come up with a um way to to talk about structure concurrency and teach people about structure concurrency And so I created this thing called Easy Racer which is a collection of obstacle courses for programs to run through that are all kind of centered around structured concurrency ideas Okay And so I I think I I think I started the initial my first implementation of Easy Racer was with Zo and most of the scenarios or obstacles in Easy Racer are doing a race It's like how easy is it to take one thing race it against another thing and get the winner out and what's cancel the loser maybe and cancel the Yeah And oh definitely cancel the loser Uh there is an obstacle that actually does validate that your race does actually cancel the loser Uh and so um so a race is this it's a a really nice simple construct and it's really fascinating to see how different languages and frameworks and approaches deal with all of the complexities to doing a race And Easy Racer gets into scenarios like what if we want to race 10,000 things all at the same time How hard is that And in the world of like Go that's actually really freaking hard Uh which is surprising because you know Go is supposed to be like this great thing for concurrency It's so easy for concurrency Turns out that uh that's not that easy in Go Even even Rust is another interesting one where where there is a nice concise race macro in Rust uh in Tokyo they're they're uh it's concurrency like the kind of the de facto standard of concurrency and rest So there's this really nice concise macrobased way to do a race but it handles at most like three things And so as soon as you get into oh I don't have three things I have a list of maybe 10,000 things You can't use the nice macro anymore And then you have to get into uh I think I had to use a multi-producer multi- consumer channel thing in Rust to be able to like do the race with 10,000 concurrent requests Anyway fascinating to see how do different languages and frameworks So a lot of times I am able to use easy eraser to explore a lot of these concepts of structure concurrency and effects are part of some of those So places where I can use effects uh like like I I learned Kio by implementing the easy racer obstacles in in Kio and that was a super fun way to learn that Uh somebody contributed Okamel once which was awesome because we'd done a podcast episode with somebody on Ocamel So it was and and tinkered a bit in Ocamel but then somebody came up with the OAML easyraer implementation and there's there's actually two of them One of them uses their like algebraic effects uh but the other one uses a library in Okamel And this is actually one of the cleanest implementations of easyer was the Okamel one which was kind of fascinating That's interesting Yeah And so easyer just gives me this really fun place to learn new language It makes it like a test bed for your for experimentation and for learning Am I getting this right Yeah Yeah Exactly And and this one just happens to be you know around structure concurrency because just there's some some fun problems there and it's fun to see and important problems Yeah Yeah It's like like a race is I I I use race all the time uh in in my actual programs because of course I want to like like do things concurrently and sometimes I just want to race those two things together to get to a result faster And so um so yeah it becomes a fun place to experiment and learn and uh and tinker with with weird languages and and see how they do things differently and frameworks So so there's cotton implementations there's Java one Java now has some structured concurrency uh stuff in in Loom and so um so yeah lots of different lots of different things that I've learned by going through Easy Racer and and trying to implement those obstacles with different languages and frameworks This is interesting Do you ever use uh AI or LLMs for learning or experimentation when you try new things Where do you start reading documentation and whatever Oh I I am very reliant on the AI now for especially areas that I'm not familiar with If I'm working in Scola and Zo I can I can just like bang out the code you know and most of the the the code is concise enough because I'm using effects and I'm using Scola that the thinking about the types and the operations on those types is something that I can just as easily and quickly do in code and I think more faster than it would be to do it in English and so I I can do my thinking That says something about the effect systems by the way Yeah exactly right that that I can productively think in code versus when I'm when I go into other areas that I'm not as familiar with or aren't as powerful require a lot more boilerplate whatever then the AI is massively helpful for for helping me quickly you know get to code that maybe kind of works and is probably crap I'm going to have to rewrite it Um because uh the it's one of the fascinating things about about the AI writing code for me The way that I I kind of see it is that it's trained on all this code that's you know out there in the world And I don't write I think there's like this this uh gravity to um I don't know like like generally bad code because most of the code that's out there online is like like not the code that I want to write It's like like it it's kind of crap And so so what I what I've seen from all the AIS is that they can generate code for you and be really helpful but and and help me get to like something that works but then I generally have to rewrite the code because it's not written with the the the mentality that I want to bring to code of all the things we've been talking about is like how can I better represent this in types How can I use effects like like uh there's I was just writing some Java code last night and I like to use a var because in in Java because I don't want the type signature in both places like it just is kind of silly to have it on the left and the right You know this from the world of Scola and Cotlin And so sure it's great to like like in Java now we can just say var and not have to specify it on the left Um but generally the LM is not generating that kind of code for me I probably like put it into like a system prompt and you know like I probably could prompt it to do it but the default from these LLM is to do write the code like is most existing in the world of code And so it's not giving me the necessarily the code that I want to write which is kind of fascinating But I think you know with MCP and some of these other things we can talk about like we're going to be able to to manage some of the some of those those pieces But um yeah so I think generally the AI code assistance I use I work at Amazon and we've got this thing called Q developer and it has an Intelligj plugin and so I generally use that for for my AI code assistant Um and it's it's good There's there's some nice things to it They also now have a CLI So if you want to do like the agentic um stuff in a CLI you can do that And I've I've been playing with that Uh was using that recently This was kind of a fascinating one I was uh there's this language moonbit Uh which which is kind of a Wom native language And I don't for some reason I I got triggered because they had this benchmark that was like we're eight times faster than Java and I was like huh interesting Let me crack Uh yeah let me let me see what's going on here And so so I I didn't know Moonbit And so uh so I got the project and took me a while to figure out how to get the tooling installed because I don't do the curl pipe through bash thing I just like like like like disallowed like like for me I'm not going to install your stuff through curl pipe through bash So I had to like look at their install script and figure out how to like sely install moon bit But anyways got this thing installed Got moon bit installed Got the java application um working compiling and installed and I was like okay what what's going on here like like what what is this benchmark even doing the benchmark was written in Rust so I was using the AI to like help me understand Rust because I'm I'm kind of I'm definitely a novice at Rust so I was using the LM to like like help me understand what was going on uh but then um then I was like oh can I optimize this Java program and so first I had to understand okay what's the benchmark doing Turns out the benchmark is basically just benchmarking JVM startup time for the the JVM version one not the Java program But then they also had a a Growl one and the Moonbit one uh native moon bit was was still a lot faster than the crawl VM one And I was like that's curious I want to understand more like like what why that could be And so I pointed in my case the the QCLI agent to to the Java program and I said like optimize this thing and run the benchmark and just keep going until you get the Java growl VM one faster than the moon bit one Fascinating right And so like which was was super fun because then I'm seeing like oh it's like okay we've got to like make this change to the Java code and then let's test it and then oh we're going to change the algorithm this is doing a fast for uh transform or something like that was the particular benchmark So then I started tweaking the algorithm uh and it was just and I'm just like watching this thing go and iterating Um but was what was what was funny was it's doing this and I let it just just run and I have to like you know try some different prompts and all this kind of stuff but I'm just letting this like agent like do this this work and it's trying all these things and it it is making like some improvement on the benchmark but but not not significant improvement And so I I then I'm I'm looking at this and I'm like like why like this is grow VM it's native like like what is going on here why is it why is it slow and so uh then I was like oh profilers we have tools in Java that make it easy to see what's going on here and so I then run run the Java application just on the JVM and the profiler and IntelliJ was great it's like here's your flame graph and it turns out that the actual fast for year transform piece of the program was like 5% of the overall wow execution time of the program So it turned out the benchmark wasn't even like like testing really the important thing and the agent that I'd set loose on optimizing this thing It was optimizing this thin little sliver of the execution time So it turned out that the uh the slow part that was taking like 90% of the execution time was uh that at the end of doing the fast for your FFT uh it looped through the the output and did a system out print f on it and it turned out that that the print f 16,000 times was taking up like 90% of the execution time But what was funny was that the agent the agent didn't figure this out and it took me running the profiler to figure it out So both me and the agent we're spending our time on this like thin sliver of optimization uh and and not the important part So then I was like what I need to do is write an MCP server that will run the profiler on something and if I'm if I then prompt if I then provide a prompt that's like optimize this the first thing that it should do is actually run it in the profiler to understand what the hotspots are um and I can implement that through an MCP server and so anyway I didn't haven't built that yet but but um yeah it it was a fascinating kind of path to to where my brain and the AI's thinking both had kind of led in in the wrong direction Um because even I was like didn't think even I was focused on the FFT piece of this benchmark Yeah And you're hyper optimizing it but the problem was elsewhere Exactly And so it's interesting that that um it actually took me a while to to to realize where where you know where the problem where the focus needed to be and thanks to the profiler it helped me do that So of course we should be able to plug the profiler into our AI agent and then it will have all that information You have to come up with the idea to run run the profiler Yeah I have two follow-up questions to this One is how do you think about MCP and how you think this can impact our own workflow as a software engineer That's one And two uh it's kind of like a different question You can take which whichever one you like How do you feel about uh the fact that essentially most of the code that we're ever going to read is going to be increasingly LLM generated Great questions Daniel Um you can combine them You can take whichever one you like Um let's let's first talk about the the code thing So I I think that the LLM they're amazing tools super helpful They're kind of an indictment on abstractions Like like I think that the LMS have basically said like like copy and paste is a better way to write code than coming up with good abstractions So I'm actually kind of disappointed with our whole industry that instead of like leveraging good abstractions like effects like good type systems we've basically just said like ah like like I'm just going to have give me code Yeah I'm just going to have a a quicker way to copy and paste code where I used to have to go to Stack Overflow and search through things and find the code on Stack Overflow and copy the code from Stack Overflow into my codebase Now the OLM is just like doing that in a much smarter way for me but it still is like copy and paste instead of saying maybe our fundamental abstractions have been not awesome and if we had better abstractions then we wouldn't need to copy and paste so much code And so this is where I'm I still 100% believe that effects are a better abstraction And if we're if more people were using effective programming then maybe we wouldn't need to generate so much crap code uh that we'd have a better foundation of abstraction to build on top of And certainly the LM can help me generate effects oriented code Um but I hope that as an industry we continue to take steps towards better abstractions as well as the tools that help us to actually write the code and I don't know if things are necessarily going in if the gravity is going in that direction or not but there with a whole vibe coding um u style of just plowing through plowing code until until it works deploy it ship it and then never look at it again I don't know Maybe we'll see I mean I I think vibe coding can work can be compatible with good abstractions good compilers good type systems and be even more beneficial So one of the things I've wondered about is if you if you took a a base kind of foundation model and you then you built some knowledge around it of effect systems uh get like specialized it to being able to like like help you write effectiented code Well then I think like like you've got a tool that's way more powerful than the AI slop that's going to get generated you know for Python or or JavaScript or whatever It should be able to actually really increase your productivity beyond what can be done in the untyped you know less um uh non-effectful non or nonfeectoriented ways of doing things So I'm hoping that that'll be a kind of leaping innovation that I don't know who's going to do it but but uh but somebody should be able to combine good abstractions effective pro programming good strong static type systems with the LLM tools and actually get us to a much higher level of productivity than than we have today with the um with the crap that you know comes out of AIS for Python code and and maintain and your the safety of your code really I mean when you im imbue the LMS with deep knowledge about the abstractions that you wanted to include in your code then you get I mean if you if you do this right and I haven't seen a a complete recipe for it I'm certainly trying it myself on my own code but I haven't seen a complete recipe for it If you get the uh output or the productivity of the LM with the safety of a good abstraction of essentially good ideas these are what abstractions mean They're the good ideas that are embedded in your code So if you imbue the LLM with these good ideas and you make it spit out the output in the style that fits the mindset of the of your codebase then you get I think or I hope the best of both worlds in terms of code volume and also the code safety as well That's right And and then there's going to be the agentic loops that the better your compiler me error messages the uh the better information that can give to the LM to help it then iterate to a better solution And so so I think all this stuff what we're what we hopefully will discover in this is that static types are good effect systems are good tests are good and all of those things even in the they help me be a better programmer without the LLM They can also help the AI agent be a better programmer uh and get to a working solution more quickly Uh and by working I mean something that you know isn't just like oh it works once and then I can't refactor it because who knows you know what what possibly is going to break Like all the things that we talked about earlier but these these things have helped me more quickly produce better programs And so that should also be true for the LLM It's just that I don't know if we've fully kind of pulled those those threads together yet in in a way that really is is um combining the benefits So as an example to this is if you look at a lot of the code that I write I'm heavily using type inference And so in the text of my code the types are not there right like like sometimes but but rarely and so maybe in my function signatures whatever and so for the LLM that's actually a downside to type inference right like like oh I'm sending this the text representation of this code over to the LLM and now the LM's missing a lot of information but you've I'm sure seen in Intelligj you can get it to display the inferred types probably what we should be doing if we send code that it has type inference in it to the LM is we should be sending the representation with the types in it Yeah but I don't think anybody's doing that yet Um so it's just like like of course the LM is going to be able to do a better job if it has the type the types in it So so I think that'll that's a lowhanging fruit place where oh types and type inference uh hooked to the LLM uh is going to be a huge benefit to to bringing those worlds together So yeah Well we'll see How do you think uh uh MCP uh fits into the picture You t you talked about how you put an agent to work in a repeated loop and uh optimize your code run the benchmark um how do you think MCP is going to help in in the general productivity sense Yeah so quick overview on MCP the Anthropic created this uh specification for uh the model context protocol and this is an API for tools and tools are things that in uh an LLM you can say here's the tools that you have available to you like get the weather uh you can get the weather by calling this tool and then when the LLM responds it can say oh I need you to call this tool for me and then and then your program that is you know doing and all this can then make the tool call out to get the weather and then put that back into the LLM and then the LM can look at the response and be like "Okay now I know what the weather is." Um which it wasn't trained on the current weather in Crest View Colorado but it can go fetch that and then integrate that into the response Um so MCP just creates a protocol around those those tools essentially And so it's uh it's great because now we have a kind of standardized way to expose tools to the LLM and we can do it in MCP that the transport is decoupled from the protocol So we can do it over standard IO uh running on your local machine We can do it over the network with currently server and events over HTTP but they're also working on a stateless version of the the transport So um so this is great Now we're going to be able to much more easily plug things into not just our AI coding assistants but anytime we use an LLM for something we can do tool to tool calling in a standardized way So so I think there's a lot of really good things to what MCP is doing There's also um some smells of this being like the promises of of SOAP and UDI and some of the things that you know we I don't know probably 20 years ago were like oh web services and you're going to be able to like do all these things and then it never really came whatever Yeah Yeah So so you know I think there's some valid worry that that there's um that we're repeating some of the mistakes of the past here and and we'll we'll see how it goes But but I think for me I'm excited that the AI code assistants many of them are now adding MCP support and so then I have an extensibility uh lever that I can do the things like we talked about earlier where if I want to tweak something in my AI code assistant MCP gives me one lever to do that um that I think will make these tools even more useful and more capable Uh like I don't know maybe I I need to write a MCP server that will will take a code suggestion and then reformat it into James code which is different than what the rest of the internet writes Uh you know that could be an MCP server So yeah I think I'm I'm excited about the potential for for how I will use MCP servers in my flow Like the profiler case was another one that could be interesting It's like yeah like like the the LLM can't by default run a profiler on something but I could provide an MCP server that could do that and do it automatically So yeah I think there's a a lot of um potential that this is opening up the the MCP is it is pretty clearly like like one at this point like like it is like sure there's some deficiencies to it but the how quickly the support around MCP exploded I think says that this is solving maybe not solving in the best way but solving a problem that we have today in a way that is maybe not the the most ideal way but is sufficient for for getting us to to this next level Um there's there's already like thousands of MCP servers out there and this spec was just announced at the uh like three months ago or something So three four months ago So the uh Spring has support Cotlin has support I haven't looked to see what the state of MCP protocol stuff for Scola is yet but I'm sure somebody's working Yeah the support for SCA and LLM is uh uh I don't know a bit deficient at the moment I mean we uh are kind of using the raw um the raw knowledge that the most common LLMs have And but for MCP specifically for MCP specifically I'm not sure I don't I don't know of a of a good uh um I mean I think the the the virtuous lab team in uh that that's working on the Scola compiler this is the team that has the most resources allocated to the Scala compiler I think they're they're at least thinking about integrating something like that in the metals uh uh language server so yeah more it's exciting how fast it's moving my biggest uh gripe about MCP was that it didn't really bring the ideas of effects and functional programming to that world of MCP So just as an example I I may want to know in my agentic system whether it's an AI coding assistant or something you know some enterprise system that's using agents and uh and LMS and MCP Um I may want to know when I call a tool is this a item potent Uh I'm like I want to know the effect properties of this tool call Is this going to mutate something Can I call it more than once Uh can I retry it Like uh is this a potentially destructive action Like like one of the things I love in functional programming is that we try to represent those things in hopefully in types but but we try to represent them uh through uh um what what's the right word for it Like like we algebbras but like calculus like we try to like like take these concepts and try to try to convey them in uh in a in a way that then we can reason about and of course like MCP uh I I doubt that the the people that authored it are familiar with you know algebraas and like pro programming algebbras and and calculuses and effects and some of these concepts nor is the audience is the audience mostly aware of that that these sort of properties I mean the the effect mindset is not that popular yet and so I I I'm not expecting neither the the authors of the protocol nor the audience of it or the consumers of it to be too much aware of this Yeah Yeah Where do you think you are uh uh where do we where do you think we are where do you think we are in terms of the hype of uh LLM and MCPS and that are we still on the very steep ascending slope are we in for a disappointment where do you think we are there I I fluctuate on that sometimes I'm like oh we are so high up on this hype cycle and and you know it we're we're headed quickly towards the trough off of disillusionment or whatever it is like and then other times I'm like we we may still be at the beginning of the climb to what these tools can do So I don't know I I I kind of go back and forth It kind of depends maybe on um at least with AI coding assistance it depends on how good of a answer it gives me or like how how uh how sometimes I'm just like shocked like oh my god that was amazing and so good and other times I'm like you were so far off of what I wanted Um and so so I don't know It's I guess I go through through these like eb and flow or like sometimes I'm like "Oh my god I'm going to be replaced tomorrow." And other times I'm like I'm pretty sure I have a job for a long time because uh of the the slop that I I see So I don't know What do you think Where I definitely oscillate between both as well I mean certainly for Scala it's been more of a miss than a hit More I mean less so for recent models So Claude uh works pretty great for me Um if I give it very clear instructions I mean if I give it clear instructions and with a very detailed description of what I want uh what I needed to be careful with that sort of thing it produces really great results And uh my code is like I don't know uh subjectively I haven't measured it but I I feel like I'm at least two or three times as productive in terms of code writing Um and the code looks as if I wrote it So it's certainly my style because I spent a lot of time in the prompts describing the kind of things that I wanted to be careful with and so on and so forth So a bit recently I'm uh starting to like LLMs for development but uh in like recent even half a year ago I still I was still writing most of my code myself Um yeah so I think that's a sign that at least for me that's why I was curious to hear your thoughts on it uh because LLMs are only starting to become really great and really useful for me I think we're in the ascending phase of the hype of the hype cycle but I wanted to I was very curious to hear your thoughts on it Well and I think we we haven't totally figured out all of the interaction models that are are the best ones or the right ones around this because we've we now have agents So you can um you know you like set the LM free on a task and just have it iterate until it figures it out Uh and that's the the agentic one and that one I think we're there there's some some good stuff happening there around the agentic flows Um so I think that's one interaction model that's kind of emerged and you can do this in your IDE or on the command line Um but then there's other interaction models that I'm I'm curious about like um like one of the the there's obviously like the chat like asking questions and and all that Um which is super helpful Like I I'm I'm I used to ask Google a question about some code thing I don't understand and then I'd have to open up like a hundred tabs in my browser and then read through all those things and then try to get to an understanding based on all those things I read and then go into my IDE and actually try something And now I'm just in my IDE asking questions and it's doing that like 100 tab thing for me essentially and then giving me the distilled answer and and I'm not even leaving my IDE anymore which is which is I love and so so that's been been huge for me um for for for that kind of ex explorative understanding piece of of what I'm doing Um I what's what's interesting is the like co-pilot and some of the other ones the the the like the feature that they came out with that was the interaction model was the multi-line code suggestion model and I I I don't use that at all because for me like like it generally uh the the challenge is not writing those lines of code it's the thinking that I have to do to define my types define the operations on them And so I do that thinking not with the multi-line suggestion but by actually you know typing and and then maybe I maybe I get the thinking done and and then I am like okay the now that I've defined the types I've defined the operations now I can have the LM like fill in the the boiler more boiler plate oriented parts Yeah exactly And so so all that to say like like I I don't really use the the what was the initial interaction model with the LM which is the multilint suggestion essentially I don't use it um it's it it it was not uh a useful thing in my workflow but I'm also using generally low boilerplate languages and frameworks And so if I was writing JavaScript or Python or Java then maybe that feature would be a lot more beneficial because there's a lot more boilerplate to the to the code So so I guess uh we're still I think figuring out what the right interaction models uh what those look like how how how and why and when we should interact Uh so I think in that terms it's still pretty early days to like the interaction models are still heavily evolving and then of course we throw MCP in and how does that impact those interaction models It's like multiplying everything Yeah Exactly Yeah So it's it's fun sometimes Yeah I mean definitely Uh success is not guaranteed but fun is always guaranteed Um I'm having a blast writing code unless I'm writing Spring um Java code and beating my head against my desk because I can't figure out uh and my AI agent can't figure it out And uh nothing can figure it out So I'm just going to have to like actually go ask another ask ask an expert what's what's going on this Yeah I wanted to ask about it because u uh look uh I wanted by the way I wanted to be I wanted to be respectful of your time U I I know we're coming up on the initial schedule for the for wrapping up the conversation Do you happen to have more time or uh are we I I do have more time and it's so fun to talk to you D Awesome I feel the same All right Um yeah Well in that case uh I wanted to ask about the the kind of skills that you think are still relevant or even more important in the age of LMS because you were talking about um asking an expert I mean it's the fallback solution to pretty much everything You ask somebody who actually knows the stuff to fix your to fix the code How do you think about this in the age of LMS and spitting out a lot of code that you don't necessarily have to understand I mean if you're uh if you're a software engineer and you have a you have a deadline and you have to push a feature or a bug fix or whatever ask LLM spits out a bunch of code it looks kind of nice the tests seem to pass which are all generated by the LLMs by the way Um the tests pass the feature seems to work smoke testing works you ship it Um but then you get burned in production Um another use case you spit out a lot of code codebase becomes enormous it's becoming a huge blob that you cannot really maintain because you haven't actually put the time to understand That's a that's these are just two examples that are I'm pretty sure that are going to be become more frequent in the age of this is already happening for sure For sure Uh so how do you think about keeping some timeless skills or important skills for a software engineer at least the ones coming up into the industry at this moment that uh are going that you think are going to be important Yeah I mean I think it's I think it's everything we've already said um with with one additional thing I'll add but abstractions are good because you're you're totally right that whether or not the AI or human generates the code we probably should understand it and understanding is easier with higher level abstractions And so using effects is a great abstraction so that we can write more concise code that is more direct to the problem that we're trying to solve So like going back to the race example of course I should be able to do effect.ra another effect and that's very clear what I'm what I'm actually trying to do But if you look at uh other languages and frameworks like we'll just pick on Java for a second The the basic race it's a lot of code that is very far away from the problem that you're actually trying to solve which is I have an effect race it with this other effect give me the result back give me the winner back Yeah you have to think a lot of about the internal state of the the the stuff that is racing and and uh you have to keep that in your head That's right And and if the LM has created it then you have to parse through and try to understand what is this thing actually trying to do And so we call this what like expressiveness Like the more expressive our code is to the problem that we're actually trying to solve that's a good thing And having good abstractions allows us to do that more effectively And so yeah like like I I do hope that we will you not just not just rely on LLM generating a lot of code but direct the LMS to generate concise code based on good abstractions So that yes when the human has to read that code and understand what it's doing that process is actually easier because to your question we as humans we are responsible for what goes into production as developers and you know we can't hold the AI responsible like that's silly like like it's a human that ultimately is going to be responsible for something running in production Um and so we as humans should understand the code that is going into production and that is a skill that we will still need to have as developers and there's many different facets to how we understand code obviously like type systems and effects and you know there's many ways abstractions like all the things we've talked about help us to get to better understand but we got to uh test like good tests are a great way to understand what it what code is trying to do So yeah so I think I I think those skills continue to be important Somebody's got to be creating good abstractions Um for for all my picking on on Spring um it it is for many enterprise developers a a better abstraction than the alternative And the Spring folks do a great job of like creating an abstraction that is actually generally really useful and helpful and and so um so some really smart people we need them to continue to come up with the good abstractions and so yeah Zo being being another one but obviously many many like abstractions often you need really smart people to come up with good abstractions I've yet to see an LLM invent a new abstraction that was directed by somebody who already has the good idea Right Exactly Like certainly somebody who a human can come up with that good idea like like Zo we are not at the point with AIS where Zo could have been invented by an LLM right like like that was pretty novel and and took you know some really smart people to invent and involve and get get a working abstraction So we we we certainly still need those developers that can do that I'm that's not me I'm I'm not that smart I'm not that you know that kind of developer and many people have these like smart people that are able to come up with these abstractions So I'm I'm a great user of the abstractions I'm I'm not a great uh inventor of abstractions but um it's different different skill sets certainly Um so then the other thing I wanted to touch on related to this was I think as we continue to move forward in this AI world one of the things that's going to be really important is determining how we validate what working means and uh how do we know that our program works Let's let's just imagine a world where uh all that I have to do as a developer is write a really good test and if my test is sufficient it covers um more than a test I have to write my data type my interface of of what just an interface defining what the functionality on my my objects are and then I write the test Maybe there's a world where that would be sufficient information to then derive the working program that that actually you know used the data types implemented the interface and and then satisfied all the tests So let's imagine that that that's a future mode that that we could work in Then the the challenge becomes how how do I sufficiently write that test And this is where I've been exploring formal verification languages Maybe a formal verification language is the way to sufficiently write that test And then all I have to do is formally all I have to do is um generate the code that passes that Exactly Right And so that's where I'm I've been exploring uh languages um to do this So the the lean is one of the the primary languages that I've been exploring Uh the syntax is a lot like Scola So it's pretty easy to learn which is awesome Was talking Yeah And so I and oh and then I discovered that there is a Scola um variant that does some some amount of formal verification as well So I need to dive a little more into that I forget the name of that one But uh but there's this this whole space that I think has been dominated by mathematicians and super smart people that are writing these languages for formal verification And what I wonder is is this going to like like pull down into the world of a normal developer like me where I'll be able to utilize formal verification to define the specification and then derive the implementation that that that fit have the AI derive the implementation that actually passes the formal verification So I don't know That's part of what what I'm interested in seeing how that how all that stuff plays out I am very curious I mean you've you've talked about a lot of things that you've been exploring How do you how do you find the time to to to learn and study all these things I just I love learning I love I love programming and so luckily I've you know got a job where I get to learn and do programming and yeah So it makes it super fun Uh and then I get to help teach others about these things that I'm learning And so yeah it's it's I'm I'm incredibly fortunate that I'm in a setup that allows me to spend time um you know learning new things and exploring lean and and Daphne is another one that I've explored a bit another it's not quite formal verification but um but yeah so so fun that I and then I like like thankfully we live in this digitally connected world where I get to like learn from people like you and and you know see your great content and so yeah like like it's uh it what a fun time to to learn it like you know when I started programming we didn't have this we didn't have you know YouTube and content creator and super smart people teaching other people We had to go to a bookstore and buy a book on you know pull it off the shelf and then sit and read the book like like I I'm we just are in such a fun time to learn and grow and the opportunities are just endless for how we do that now So and then we get to teach others too which is super fun Yeah I can definitely vouch for that I mean teaching is uh uh super meaningful and and fun and it also sharpens my own skill as as a developer because when I have to teach somebody I have to be 10 times as careful as if I was with my own code because I because whatever I teach gets multiplied into the lives and into the production code of other people So I have to be really careful about what I what I talk about Yep Yeah It's it's such a good like forcing function for me is like if I'm going to do a presentation on something like usually what happens is I submit a CFP to a conference and it's like this idea and then it gets accepted I'm like oh now I got to go actually learn that thing And so uh it's it's has become a fun forcing function to like force me to like have to actually learn this thing because if I'm going to get up on stage and talk teach other people about something I should probably know it pretty well myself So but often I submit the CFP not actually knowing what I'm g you know I don't actually know the topic fully and so then I have to do a bunch of research and learning This is uh this is an an important tool and I I use it myself I mean when uh when I create a course or even with presentations I uh uh I had pretty much the same technique for a couple conferences that I spoke about I uh submitted a a a piece that I I submitted an idea that I particularly found interesting and when I was accepted I was like "Oh great This is a great idea but now I have to like make it real because I I'd never actually put it on paper to see how that thing would look like." So I found myself with like two weeks within two weeks of the uh of the conference frantically making that idea real and I found resources within my brain that I never thought were there Yep Yep Totally 100% Done that many times You uh this is a a nice segue into conferences because I was curious about uh your I mean you have obviously lots of experience speaking on various stages at programming conferences around the world and uh I wanted to ask about your uh your interest in in in conferences Why why do you do it I think it's what we were saying like I I do enjoy teaching things and and in part because then it forces me to learn but then there's just a lot of enjoyment that I get from from helping developers learn and grow Like that's it's so fulfilling for me to like like um I think my pin tweet right now is something along the lines of like like I don't I don't need to make myself a 10x developer What I would rather do is help I don't remember the numbers five developers become 2x developers or something like like I would rather invest in others like scale through others and help others level up then then try for like I'm not ever going to be John Deose like like John Deose is a really amazing developer I'm not going to be him But what I can do is help many other developers hopefully get better at what they do and more easily create better programs Like like that's that's uh that's the the thing that just brings me a lot of joy and it's kind of self- serving because I don't know about you but I encounter about a thousand bugs a day in the systems that I work with the you know whether it's my car I've got a great car It is buggy like like it is like it's crazy but my car has a ton of bugs and like I want software to be better because I use software Yes And so it's like self-s serving also like I I'm I'm very disappointed generally with the quality of software that I interact with and I often get want software to be better Yeah I often I often see myself having uh I mean even kind of important apps like banking and stuff and the they freeze or they crash or they uh a button isn't working like come on this is supposed to be important software it's it makes me hate software sometimes but it also energizes me to help make software better through others as you as you were speaking Exactly So yeah this is definitely a motivating factor for me as well Um and what I mean uh in a conference I mean you you spoke at on many stages what do you think from your perspective as a speaker what makes a great conference not just like like a good one a great one what is what does that make for you Yeah there it's there's a huge variety in in the conferences that I that I've gone to and and go to Um so we a couple weeks ago had the winter tech forum up here in Christ Bruce Cycle puts that together and it's a it's a small conference Um but it's all open spaces We we have great discussions learn from smart people Um it's it's kind of defined as the hallway track A conference that is only the hallway track is is kind of the winter tech forum And so th this is just a fun story from winter tech forum uh this year So just a couple weeks ago on Monday so the conference runs Monday through Friday On Monday we did a session about MCP and agents agentic stuff and I was not really leading because like there's not really a leader in the discussion It's just as a discussion but I was providing some of the things that I'd learned about MCP and building agents in in this this group of people And uh people were pretty interested like "Oh I want to build agents I want to build MCP but then I had to go to Atlanta for the Dev Nexus conference So I I missed the Tuesday Wednesday Thursday of of the Winter Tech Forum And I get back Friday on the last day And everyone had spent all week building agents and building MCP servers And I was so stoked that like like oh it's like like I wish I could have been there to to build with them But everyone like like all all the people had had built something like agentic and something with agents and like oh it was so cool to see like okay this like fun discussion that we had about using LLMs and and building agents and building MCP servers then led people to like spend the week learning how to actually do that And so that was that was super fun to see So yeah that was that that conference is definitely on a a it's a different type of conference than most of the other ones I go to Um last year I got to go to Lambda Conf and uh that was had so many amazing interactions at that one just because there's so people there I never went to Strange Loop because I felt I wasn't like cool enough or smart enough to go to to go there Um but obviously like Strange Loop is where all the like like all of my heroes hang out Lambda is I think mostly that And so I got to you know hang out with with and learn from so many smart people at Lambda last year That was that was really fun Fun story about that one I was uh I was on my way driving to Lambda and I was listening to Richard Feldman's podcast on uh with um Nathan Sobo uh the the uh one of the founders of Zed the ID Zed So I'm listening to this episode on my way to Lambda And then I get there and Nathan is at Lambda Comp just hanging out And so I spend the whole like like two days just like hanging out with Nathan who's like also one of my heroes And so I'm like hanging out with Nathan and I'm like "How cool is that?" Like listening to the podcast I had no idea you'd be here And then I meet you and then I uh build this relationship with Nathan and get him on my podcast And so that was Yeah that was super fun It's like like I I do like meeting my heroes like like you and uh Wow I'm so flattered No you like I you you really help develop so many developers level up and teach them so many good uh important things So this is the biggest compliment that I've that I've received in a while Thank you so much But yeah so so fun to like go to conferences where you can meet your heroes and um and and generally it's the heroes in our industry are amazing people and smart and we have so much to learn from and they usually like want to help others learn So yeah I guess that recap conferences like like that's the best part for me is like getting to do that Similar for me I I was curious how how you felt about it Um it's definitely the meeting great smart people that are also willing to to help you or or um help I mean there's a a vibe in a good conference where all of us help each other grow and learn and be better developers and better contributors to the world of software because a lot of the world relies on software So it's kind of like a shared responsibility to um uh to help each other grow And yeah likewise I mean uh when I when I got to my first scholar conference and met Martin Oderski my my scholar hero and probably everybody's scholar hero I I felt a very similar feeling and uh it's definitely a good vibe And uh if you have a conference that as you said about um uh the winter one and uh it's where people start building stuff and you have this energy of constructive uh people putting in all their efforts and on all their knowledge into learning and also making useful stuff That's uh that's a that's a jackpot I one of my uh I mean I keep daydreaming that one I I'm going to be able to organize such a such an event myself but I don't know if that that's ever gonna come to fruition My might uh nice I'd love to go out for it So keep updated We'll see Yeah So um James it's been so much fun and we covered a lot of ground Is there anything that you would like to share with uh my audience Maybe a thought or a piece of advice or anything before we draw this conversation to a close I want to be respectful of your time and we went over the scheduled time So uh ah so so fun to talk to you Yeah And I I I do really appreciate all that you do to help developers grow and and learn And so um yeah no no other thoughts but just thank you for for teeing up this conversation because it is so fun to have these conversations So yeah appreciate you and appreciate uh this opportunity Thank you James Thank you so much for coming and for everybody who's listening and watching we're going to have links to everything that we discussed And uh until next time thank you for watching and I'll see you next time Thank you James Thanks 
